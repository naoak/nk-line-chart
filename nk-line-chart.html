<link rel="import" href="../polymer/polymer.html">

<!--
`nk-line-chart`
Very simple line chart web component

@demo demo/index.html
-->

<dom-module id="nk-line-chart">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <div id="container"></div>
  </template>
</dom-module>

<script>
(function() {
  'use strict';

  var NS = 'http://www.w3.org/2000/svg';

  Polymer({

    is: 'nk-line-chart',

    properties: {

      /**
       * Data rows
       *
       * ```
       * (ex)
       * [
       *   {x: 0, y: 0}, {x: 1, y: 1}
       * ]
       * ```
       */
      rows: {
        type: Array
      },

      /**
       * Style of points
       */
      circleStyle: {
        type: Object,
        value: {
          r: '3',
          stroke: 'none',
          strokeWidth: '0',
          fill: '#e08080'
        }
      },

      /**
       * Style of a polygonal line
       */
      pathStyle: {
        type: Object,
        value: {
          stroke: '#e08080',
          strokeWidth: '2',
          fillOpacity: '1',
          fill: 'none'
        }
      },

      /**
       * Chart Area. `top`, `left`, `width` and `height` are required.
       */
      chartArea: {
        type: Object
      }
    },

    observers: [
      '_rowsAndStyleChanged(rows, circleStyle, pathStyle)'
    ],

    _rowsAndStyleChanged: function(rows, circleStyle, pathStyle) {
      this.debounce('draw', function() {
        if (this._svg) {
          Polymer.dom(this.$.container).remove(this._svg);
        }
        this._svg = this._draw(
          calcPoints(rows, this.chartArea), toAttributes(circleStyle), toAttributes(pathStyle)
        );
        this.$.container.appendChild(this._svg);
      });
    },

    _draw: function(points, circleAttrs, pathAttrs) {
      var container = this.$.container;
      var svg = document.createElementNS(NS, 'svg');
      var g0 = document.createElementNS(NS, 'g');
      var g1c = document.createElementNS(NS, 'g');

      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.appendChild(descartes(g0, this.chartArea));
      g0.appendChild(g1c);
      points.forEach(function(p) {
        g1c.appendChild(this._drawCircle(document.createElementNS(NS, 'circle'), p, circleAttrs));
      }.bind(this));
      g0.appendChild(this._drawPath(document.createElementNS(NS, 'path'), points[0], pointsToMoves(points), pathAttrs));
      return svg;
    },

    _drawPath: function(path, startPoint, moves, attrs) {
      var d = 'M' + startPoint.x + ',' + startPoint.y;
      d = moves.reduce(function(memo, vector) {
        return memo + 'l' + vector.x + ',' + vector.y;
      }, d);
      path.setAttribute('d', d);
      setAttributes(path, attrs);
      return path;
    },

    _drawCircle: function(circle, point, attrs) {
      circle.setAttribute('cx', point.x);
      circle.setAttribute('cy', point.y);
      setAttributes(circle, attrs);
      return circle;
    }
  });

  function calcPoints(rows, chartArea) {
    var top = chartArea.top;
    var left = chartArea.left;
    var width = chartArea.width;
    var height = chartArea.height;
    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = Number.MIN_VALUE;
    var maxY = Number.MIN_VALUE;
    var factorX;
    var factorY;

    if (rows && rows.length < 2) {
      throw Exception('rows length must be at least two.');
    }
    rows.forEach(function(r) {
      if (r.x < minX) {
        minX = r.x;
      }
      if (r.x > maxX) {
        maxX = r.x;
      }
      if (r.y < minY) {
        minY = r.y;
      }
      if (r.y > maxY) {
        maxY = r.y;
      }
    });
    factorX = width / (maxX - minX);
    factorY = height / (maxY - minY);

    return rows.map(function(r) {
      return {
        x: r.x * factorX + left,
        y: r.y * factorY + top
      };
    });
  }

  function pointsToMoves(points) {
    var moves = [];
    var prevP;
    points.forEach(function(p) {
      if (prevP) {
        var move = {
          x: p.x - prevP.x,
          y: p.y - prevP.y
        };
        moves.push(move);
      }
      prevP = p;
    });
    return moves;
  }

  function setAttributes(element, attrs) {
    Object.keys(attrs).forEach(function(attrName) {
      element.setAttribute(attrName, attrs[attrName]);
    });
  }

  function toAttributes(properties) {
    return Object.keys(properties).reduce(function(memo, propName) {
      var attrName = Polymer.CaseMap.camelToDashCase(propName);
      memo[attrName] = properties[propName];
      return memo;
    }, {});
  }

  function descartes(element, chartArea) {
    element.setAttribute('transform', 'translate(0,' + (chartArea.height + 2 * chartArea.top) + ') scale(1, -1)');
    return element;
  }
})();
</script>
