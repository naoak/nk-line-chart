<link rel="import" href="../polymer/polymer.html">

<!--
`nk-line-chart`
A very lightweight polymer component for drawing line charts.

@demo demo/index.html
-->

<dom-module id="nk-line-chart">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <div id="container"></div>
  </template>
</dom-module>

<script>
(function() {
  'use strict';

  var NS = 'http://www.w3.org/2000/svg';

  Polymer({

    is: 'nk-line-chart',

    properties: {

      /**
       * Style for the background rect of the chart area
       */
      backgroundRectStyle: {
        type: Object,
        value: function() {
          return {
            fill: 'none',
            stroke: 'none'
          };
        }
      },

      /**
       * An object to configure the placement and size of the chart area.
       *
       * The following members are required.
       * `top`, `left`, `width`, `height`
       * Currently, the supported format is only a number of pixels.
       *
       * Example:
       * ```
       * {
       *   top: 10,
       *   left: 10,
       *   width: 320,
       *   height: 100
       * }
       * ```
       */
      chartArea: {
        type: Object
      },

      /**
       * Style for points
       */
      circleStyle: {
        type: Object,
        value: function() {
          return {
            fill: '#e08080',
            r: '3',
            stroke: 'none',
            strokeWidth: 0
          };
        }
      },

      /**
       * The origin of coordinates. The possible values are,
       *
       * ```
       * left-bottom: cartesian cordinates
       * left-top: screen cordinates
       * right-top
       * right-bottom
       * ```
       */
      origin: {
        type: String,
        value: 'left-bottom'
      },

      /**
       * Style for polygonal lines
       */
      pathStyle: {
        type: Object,
        value: function() {
          return {
            fill: 'none',
            stroke: '#e08080',
            strokeWidth: 2,
          };
        }
      },

      /**
       * Data rows
       *
       * ```
       * (ex)
       * [
       *   [0, 0], [1, 1]
       * ]
       * ```
       */
      rows: {
        type: Array
      },

      /**
       * X-axis range of chart area. If not specified, the range will be computed by data rows.
       *
       * ```
       * min: X-axis value at the left (right if the origin is right) of chart area
       * max: X-axis value at the right (left if the origin is right) of chart area
       * ```
       */
      xRange: {
        type: Object,
        value: null
      },

      /**
       * Y-axis range of chart area. If not specified, the range will be computed by data rows.
       *
       * ```
       * min: Y-axis value at the bottom (top if the origin is top) of chart area
       * max: Y-axis value at the top (bottom if the origin is top) of chart area
       * ```
       */
      yRange: {
        type: Object,
        value: null
      },

      _transformer: {
        type: Function,
        computed: '_computeTransformer(origin, chartArea)'
      }
    },

    observers: [
      '_rowsAndStylesChanged(backgroundRectStyle, chartArea.*, circleStyle, origin, pathStyle, rows, xRange, yRange)'
    ],

    _computeTransformer: function(origin, chartArea) {
      return getTransformer(origin, chartArea);
    },

    _draw: function(svg, points, backgroundRectAttrs, circleAttrs, pathAttrs) {
      var g0 = document.createElementNS(NS, 'g');
      var g1c = document.createElementNS(NS, 'g');

      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.appendChild(g0);
      g0.appendChild(this._drawBackgroundRect(
        document.createElementNS(NS, 'rect'),
        this.chartArea, backgroundRectAttrs
      ));
      if (points.length > 0) {
        g0.appendChild(this._drawPath(
          document.createElementNS(NS, 'path'),
          points[0], pointsToMoves(points), pathAttrs
        ));
      }
      g0.appendChild(g1c);
      points.forEach(function(p) {
        g1c.appendChild(this._drawCircle(
          document.createElementNS(NS, 'circle'),
          p, circleAttrs
        ));
      }.bind(this));
      return svg;
    },

    _drawBackgroundRect: function(rect, chartArea, attrs) {
      rect.setAttribute('x', chartArea.left);
      rect.setAttribute('y', chartArea.top);
      rect.setAttribute('width', chartArea.width);
      rect.setAttribute('height', chartArea.height);
      setAttributes(rect, attrs);
      return rect;
    },

    _drawCircle: function(circle, point, attrs) {
      point = this._transformer.convertPoint(point);
      circle.setAttribute('cx', point.x);
      circle.setAttribute('cy', point.y);
      setAttributes(circle, attrs);
      return circle;
    },

    _drawPath: function(path, startPoint, moves, attrs) {
      var transformer = this._transformer;
      startPoint = transformer.convertPoint(startPoint);
      var d = moves.reduce(function(memo, vector) {
        vector = transformer.convertVector(vector);
        return memo + 'l' + vector.x + ',' + vector.y;
      }, 'M' + startPoint.x + ',' + startPoint.y);
      path.setAttribute('d', d);
      setAttributes(path, attrs);
      return path;
    },

    _rowsAndStylesChanged: function(backgroundRectStyle, chartArea_, circleStyle, origin, pathStyle, rows, xRange, yRange) {
      this.debounce('draw', function() {
        var container = this.$.container;
        if (this._svg) {
          container.removeChild(this._svg);
        }
        this._svg = null;
        if (rows && this.chartArea && circleStyle && pathStyle) {
          this._svg = this._draw(
            document.createElementNS(NS, 'svg'),
            calcPoints(rows, this.chartArea, xRange, yRange), toAttributes(backgroundRectStyle), toAttributes(circleStyle), toAttributes(pathStyle)
          );
          container.appendChild(this._svg);
        }
      });
    }
  });

  function calcPoints(rows, chartArea, xRange, yRange) {
    var top = chartArea.top || 0;
    var left = chartArea.left || 0;
    var width = chartArea.width;
    var height = chartArea.height;
    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = Number.MIN_VALUE;
    var maxY = Number.MIN_VALUE;
    var factorX;
    var factorY;
    var constantX = width / 2 + left;
    var constantY = height / 2 + top;

    rows.forEach(function(r) {
      if (r[0] < minX) {
        minX = r[0];
      }
      if (r[0] > maxX) {
        maxX = r[0];
      }
      if (r[1] < minY) {
        minY = r[1];
      }
      if (r[1] > maxY) {
        maxY = r[1];
      }
    });
    if (xRange) {
      minX = typeof(xRange.min) === 'number' ? xRange.min : minX;
      maxX = typeof(xRange.max) === 'number' ? xRange.max : maxX;
    }
    if (yRange) {
      minY = typeof(yRange.min) === 'number' ? yRange.min : minY;
      maxY = typeof(yRange.max) === 'number' ? yRange.max : maxY;
    }
    factorX = width / (maxX - minX);
    factorY = height / (maxY - minY);

    return rows.map(function(r) {
      return {
        x: isFinite(factorX) ? (r[0] - minX) * factorX + left : constantX,
        y: isFinite(factorY) ? (r[1] - minY) * factorY + top : constantY
      };
    });
  }

  function getTransformer(origin, chartArea) {
    var transformer;

    switch (origin) {

      // cartesian coordinates
      case 'left-bottom':
        transformer = [
          function(point) {
            var result = {};
            result.x = point.x;
            result.y = chartArea.height + 2 * (chartArea.top || 0) - point.y;
            return result;
          },
          function(vector) {
            var result = {};
            result.x = vector.x;
            result.y = -vector.y;
            return result;
          }
        ];
        break;

      case 'right-bottom':
        transformer = [
          function(point) {
            var result = {};
            result.x = chartArea.width + 2 * (chartArea.left || 0) - point.x;
            result.y = chartArea.height + 2 * (chartArea.top || 0) - point.y;
            return result;
          },
          function(vector) {
            var result = {};
            result.x = -vector.x;
            result.y = -vector.y;
            return result;
          }
        ];
        break;

      case 'right-top':
        transformer = [
          function(point) {
            var result = {};
            result.x = chartArea.width + 2 * (chartArea.left || 0) - point.x;
            result.y = point.y;
            return result;
          },
          function(vector) {
            var result = {};
            result.x = -vector.x;
            result.y = vector.y;
            return result;
          }
        ];
        break;

      // screen coordinates
      case 'left-top':
      default:
        transformer = [
          function(point) {
            return point;
          },
          function(vector) {
            return vector;
          }
        ];
        break;
    }

    return {
      convertPoint: transformer[0],
      convertVector: transformer[1]
    };
  }

  function pointsToMoves(points) {
    var prevP;
    var moves = [];

    points.forEach(function(p) {
      if (prevP) {
        var move = {
          x: p.x - prevP.x,
          y: p.y - prevP.y
        };
        moves.push(move);
      }
      prevP = p;
    });
    return moves;
  }

  function setAttributes(element, attrs) {
    Object.keys(attrs).forEach(function(attrName) {
      element.setAttribute(attrName, attrs[attrName]);
    });
  }

  function toAttributes(properties) {
    return Object.keys(properties).reduce(function(memo, propName) {
      var attrName = Polymer.CaseMap.camelToDashCase(propName);
      memo[attrName] = properties[propName];
      return memo;
    }, {});
  }

})();
</script>
