<link rel="import" href="../polymer/polymer.html">

<!--
`nk-line-chart`
A very lightweight polymer component for drawing line charts.

@demo demo/index.html
-->

<dom-module id="nk-line-chart">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <div id="container"></div>
  </template>
</dom-module>

<script>
(function() {
  'use strict';

  var NS = 'http://www.w3.org/2000/svg';

  Polymer({

    is: 'nk-line-chart',

    properties: {

      /**
       * Data rows
       *
       * ```
       * (ex)
       * [
       *   [0, 0], [1, 1]
       * ]
       * ```
       */
      rows: {
        type: Array
      },

      /**
       * An object to configure the placement and size of the chart area.
       *
       * The following members are required.
       * `top`, `left`, `width`, `height`
       * Currently, the supported format is only a number of pixels.
       *
       * Example:
       * ```
       * {
       *   top: 10,
       *   left: 10,
       *   width: 320,
       *   height: 100
       * }
       * ```
       */
      chartArea: {
        type: Object
      },

      /**
       * The origin of coordinates. The possible values are,
       *
       * ```
       * left-bottom: cartesian cordinates
       * left-top: cordinates of display
       * ```
       */
      origin: {
        type: String,
        value: 'left-bottom'
      },

      /**
       * Style of points
       */
      circleStyle: {
        type: Object,
        value: {
          r: '3',
          stroke: 'none',
          strokeWidth: '0',
          fill: '#e08080'
        }
      },

      /**
       * Style of a polygonal line
       */
      pathStyle: {
        type: Object,
        value: {
          stroke: '#e08080',
          strokeWidth: '2',
          fillOpacity: '1',
          fill: 'none'
        }
      }
    },

    observers: [
      '_rowsAndStylesChanged(rows, chartArea.*, origin, circleStyle, pathStyle)'
    ],

    _rowsAndStylesChanged: function(rows, chartArea_, origin, circleStyle, pathStyle) {
      this.debounce('draw', function() {
        var container = this.$.container;
        if (this._svg) {
          container.removeChild(this._svg);
        }
        this._svg = null;
        if (rows && this.chartArea && origin && circleStyle && pathStyle) {
          this._svg = this._draw(
            document.createElementNS(NS, 'svg'),
            calcPoints(rows, this.chartArea), toAttributes(circleStyle), toAttributes(pathStyle)
          );
          container.appendChild(this._svg);
        }
      });
    },

    _draw: function(svg, points, circleAttrs, pathAttrs) {
      var g0 = document.createElementNS(NS, 'g');
      var g1c = document.createElementNS(NS, 'g');

      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.appendChild(transformCoordinates(g0, this.chartArea, this.origin));
      if (points.length > 0) {
        g0.appendChild(this._drawPath(
          document.createElementNS(NS, 'path'),
          points[0], pointsToMoves(points), pathAttrs
        ));
      }
      g0.appendChild(g1c);
      points.forEach(function(p) {
        g1c.appendChild(this._drawCircle(
          document.createElementNS(NS, 'circle'),
          p, circleAttrs
        ));
      }.bind(this));
      return svg;
    },

    _drawPath: function(path, startPoint, moves, attrs) {
      var d = moves.reduce(function(memo, vector) {
        return memo + 'l' + vector.x + ',' + vector.y;
      }, 'M' + startPoint.x + ',' + startPoint.y);
      path.setAttribute('d', d);
      setAttributes(path, attrs);
      return path;
    },

    _drawCircle: function(circle, point, attrs) {
      circle.setAttribute('cx', point.x);
      circle.setAttribute('cy', point.y);
      setAttributes(circle, attrs);
      return circle;
    }
  });

  function calcPoints(rows, chartArea) {
    var top = chartArea.top || 0;
    var left = chartArea.left || 0;
    var width = chartArea.width;
    var height = chartArea.height;
    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = Number.MIN_VALUE;
    var maxY = Number.MIN_VALUE;
    var factorX;
    var factorY;
    var constantX = width / 2 + left;
    var constantY = height / 2 + top;

    rows.forEach(function(r) {
      if (r[0] < minX) {
        minX = r[0];
      }
      if (r[0] > maxX) {
        maxX = r[0];
      }
      if (r[1] < minY) {
        minY = r[1];
      }
      if (r[1] > maxY) {
        maxY = r[1];
      }
    });
    factorX = width / (maxX - minX);
    factorY = height / (maxY - minY);

    return rows.map(function(r) {
      return {
        x: isFinite(factorX) ? (r[0] - minX) * factorX + left : constantX,
        y: isFinite(factorY) ? (r[1] - minY) * factorY + top : constantY
      };
    });
  }

  function pointsToMoves(points) {
    var prevP;
    var moves = [];

    points.forEach(function(p) {
      if (prevP) {
        var move = {
          x: p.x - prevP.x,
          y: p.y - prevP.y
        };
        moves.push(move);
      }
      prevP = p;
    });
    return moves;
  }

  function setAttributes(element, attrs) {
    Object.keys(attrs).forEach(function(attrName) {
      element.setAttribute(attrName, attrs[attrName]);
    });
  }

  function toAttributes(properties) {
    return Object.keys(properties).reduce(function(memo, propName) {
      var attrName = Polymer.CaseMap.camelToDashCase(propName);
      memo[attrName] = properties[propName];
      return memo;
    }, {});
  }

  function transformCoordinates(element, chartArea, origin) {
    var transform = 'none';

    if (origin === 'left-bottom') {
      transform = 'translate(0,' + (chartArea.height + 2 * (chartArea.top || 0)) + ') scale(1, -1)';
    }
    else if (origin === 'left-top') {
      transform = '';
    }
    element.setAttribute('transform', transform);
    return element;
  }
})();
</script>
