<link rel="import" href="../polymer/polymer.html">

<!--
`nk-line-chart`
A very lightweight polymer component for drawing line charts.

@demo demo/index.html
-->

<dom-module id="nk-line-chart">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <div id="container"></div>
  </template>
</dom-module>

<script>
(function() {
  'use strict';

  var NS = 'http://www.w3.org/2000/svg';

  Polymer({

    is: 'nk-line-chart',

    properties: {

      /**
       * Style for the background rect of the chart area
       */
      backgroundRectStyle: {
        type: Object,
        value: function() {
          return {
            fill: 'none',
            stroke: 'none'
          };
        }
      },

      /**
       * An object to configure the placement and size of the chart area.
       *
       * The following members are required.
       * `top`, `left`, `width`, `height`
       * Currently, the supported format is only a number of pixels.
       *
       * Example:
       * ```
       * {
       *   top: 10,
       *   left: 10,
       *   width: 320,
       *   height: 100
       * }
       * ```
       */
      chartArea: {
        type: Object
      },

      /**
       * (DEPRECATED) Style for points
       */
      circleStyle: {
        type: Object,
        value: function() {
          return {
            fill: '#e08080',
            r: '3',
            stroke: 'none',
            strokeWidth: 2
          };
        }
      },

      /**
       * The origin of coordinates. The possible values are,
       *
       * ```
       * left-bottom: cartesian cordinates
       * left-top: screen cordinates
       * right-top
       * right-bottom
       * ```
       */
      origin: {
        type: String,
        value: 'left-bottom'
      },

      /**
       * Style for polygonal lines
       */
      pathStyle: {
        type: Object,
        value: function() {
          return {
            fill: 'none',
            stroke: '#e08080',
            strokeWidth: 2,
          };
        }
      },

      /**
       * Option for labels at points
       *
       * ```
       * enable: whether show labels or not (boolean)
       * textFormat: function for label formatter (function(row, index))
       * offset: offset from label ({x, y})
       * textStyle: text styles (object)
       * ```
       */
      labelAtPoint: {
        type: Object,
        value: function() {
          return {
            enable: false,
            offset: {
              y: -10
            },
            textFormat: formatLabel,
            textStyle: {
              fill: '#333',
              textAnchor: 'middle'
            }
          };
        }
      },

      /**
       * Option for points
       *
       * ```
       * enable: Whether show points or not
       * elements: Array of items which define element nodes for points. Currently, the only permittable type is `circle`
       *
       * (ex) A point which consists of two different circles.
       * elements: [
       *   {
       *     type: 'circle',
       *     style: {
       *       fill: '#fff',
       *       r: '6',
       *       stroke: 'none',
       *       strokeWidth: 0
       *     }
       *   },
       *   {
       *     type: 'circle',
       *     style: {
       *       fill: '#e08080',
       *       r: '3',
       *       stroke: 'none',
       *       strokeWidth: 0
       *     }
       *    }
       *  ]
       * ```
       */
      pointOption: {
        type: Object,
        value: function() {
          return {
            enable: true,
            elements: [
              {
                type: 'circle',
                style: {
                  fill: '#fff',
                  r: '5',
                  stroke: '#000',
                  strokeWidth: 2
                }
              },
              {
                type: 'circle',
                style: {
                  fill: '#e08080',
                  r: '3',
                  stroke: 'none',
                  strokeWidth: 0
                }
              }
            ]
          };
        },
      },

      /**
       * Data rows
       *
       * ```
       * (ex)
       * [
       *   [0, 0], [1, 1]
       * ]
       * ```
       */
      rows: {
        type: Array
      },

      /**
       * X-axis range of chart area. If not specified, the range will be computed by data rows.
       *
       * ```
       * min: X-axis value at the left (right if the origin is right) of chart area
       * max: X-axis value at the right (left if the origin is right) of chart area
       * ```
       */
      xRange: {
        type: Object,
        value: null
      },

      /**
       * Y-axis range of chart area. If not specified, the range will be computed by data rows.
       *
       * ```
       * min: Y-axis value at the bottom (top if the origin is top) of chart area
       * max: Y-axis value at the top (bottom if the origin is top) of chart area
       * ```
       */
      yRange: {
        type: Object,
        value: null
      },

      _transformer: {
        type: Function,
        computed: '_computeTransformer(origin, chartArea)'
      }
    },

    observers: [
      '_paramsChanged(backgroundRectStyle, chartArea.*, circleStyle, origin, pathStyle, pointOption, labelAtPoint.*, rows, xRange, yRange)'
    ],

    _computeTransformer: function(origin, chartArea) {
      return getTransformer(origin, chartArea);
    },

    _draw: function(svg, points, backgroundRectAttrs, pathAttrs) {
      var pointOption = this.pointOption;
      var circleStyle = this.circleStyle;
      var g0 = document.createElementNS(NS, 'g');
      var g1c = document.createElementNS(NS, 'g');
      var g1t = document.createElementNS(NS, 'g');

      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.appendChild(g0);
      g0.appendChild(this._drawBackgroundRect(
        document.createElementNS(NS, 'rect'),
        this.chartArea, backgroundRectAttrs
      ));
      if (points.length > 0) {
        g0.appendChild(this._drawPath(
          document.createElementNS(NS, 'path'),
          points[0], pointsToMoves(points), pathAttrs
        ));
      }
      g0.appendChild(g1c);
      g0.appendChild(g1t);
      if (pointOption && pointOption.enable) {
        points.forEach(function(p) {
          pointOption.elements.forEach(function(e) {
            if (e.type === 'circle') {
              g1c.appendChild(this._drawCircle(
                document.createElementNS(NS, e.type),
                p, toAttributes(e.style)
              ));
            }
          }.bind(this))
        }.bind(this));
      }
      else if (circleStyle) {
        points.forEach(function(p) {
          g1c.appendChild(this._drawCircle(
            document.createElementNS(NS, 'circle'),
            p, toAttributes(circleStyle)
          ));
        }.bind(this));
      }
      if (this.labelAtPoint && this.labelAtPoint.enable) {
        points.forEach(function(p, i) {
          g1t.appendChild(this._drawLabelAtPoint(
            document.createElementNS(NS, 'text'),
            p, i
          ));
        }.bind(this));
      }
      return svg;
    },

    _drawBackgroundRect: function(rect, chartArea, attrs) {
      rect.setAttribute('x', chartArea.left);
      rect.setAttribute('y', chartArea.top);
      rect.setAttribute('width', chartArea.width);
      rect.setAttribute('height', chartArea.height);
      setAttributes(rect, attrs);
      return rect;
    },

    _drawCircle: function(circle, point, attrs) {
      point = this._transformer.convertPoint(point);
      circle.setAttribute('cx', point.x);
      circle.setAttribute('cy', point.y);
      setAttributes(circle, attrs);
      return circle;
    },

    _drawPath: function(path, startPoint, moves, attrs) {
      var transformer = this._transformer;
      startPoint = transformer.convertPoint(startPoint);
      var d = moves.reduce(function(memo, vector) {
        vector = transformer.convertVector(vector);
        return memo + 'l' + vector.x + ',' + vector.y;
      }, 'M' + startPoint.x + ',' + startPoint.y);
      path.setAttribute('d', d);
      setAttributes(path, attrs);
      return path;
    },

    _drawLabelAtPoint: function(text, point, index) {
      var option = this.labelAtPoint;
      var offset = option.offset || {};
      var row = this.rows[index];
      var attrs = toAttributes(option.textStyle);
      var formatter = option.textFormat || formatLabel;
      point = this._transformer.convertPoint(point);
      text.setAttribute('x', point.x + (offset.x || 0));
      text.setAttribute('y', point.y + (offset.y || -10));
      setAttributes(text, attrs);
      text.textContent = formatter(row, index);
      return text;
    },

    _paramsChanged: function(backgroundRectStyle, chartArea_, circleStyle, origin, pathStyle, pointOption, labelAtPoint_, rows, xRange, yRange) {
      this.debounce('draw', function() {
        var container = this.$.container;
        if (this._svg) {
          container.removeChild(this._svg);
        }
        this._svg = null;
        if (rows && this.chartArea) {
          this._svg = this._draw(
            document.createElementNS(NS, 'svg'),
            calcPoints(rows, this.chartArea, xRange, yRange),
            toAttributes(backgroundRectStyle),
            toAttributes(pathStyle)
          );
          container.appendChild(this._svg);
        }
      });
    }
  });

  function calcPoints(rows, chartArea, xRange, yRange) {
    var top = chartArea.top || 0;
    var left = chartArea.left || 0;
    var width = chartArea.width;
    var height = chartArea.height;
    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = Number.MIN_VALUE;
    var maxY = Number.MIN_VALUE;
    var factorX;
    var factorY;
    var constantX = width / 2 + left;
    var constantY = height / 2 + top;

    rows.forEach(function(r) {
      if (r[0] < minX) {
        minX = r[0];
      }
      if (r[0] > maxX) {
        maxX = r[0];
      }
      if (r[1] < minY) {
        minY = r[1];
      }
      if (r[1] > maxY) {
        maxY = r[1];
      }
    });
    if (xRange) {
      minX = typeof(xRange.min) === 'number' ? xRange.min : minX;
      maxX = typeof(xRange.max) === 'number' ? xRange.max : maxX;
    }
    if (yRange) {
      minY = typeof(yRange.min) === 'number' ? yRange.min : minY;
      maxY = typeof(yRange.max) === 'number' ? yRange.max : maxY;
    }
    factorX = width / (maxX - minX);
    factorY = height / (maxY - minY);

    return rows.map(function(r) {
      return {
        x: isFinite(factorX) ? (r[0] - minX) * factorX + left : constantX,
        y: isFinite(factorY) ? (r[1] - minY) * factorY + top : constantY
      };
    });
  }

  function formatLabel(row, index) {
    return '[' + row + ']';
  }

  function getTransformer(origin, chartArea) {
    var transformer;

    switch (origin) {

      // cartesian coordinates
      case 'left-bottom':
        transformer = [
          function(point) {
            var result = {};
            result.x = point.x;
            result.y = chartArea.height + 2 * (chartArea.top || 0) - point.y;
            return result;
          },
          function(vector) {
            var result = {};
            result.x = vector.x;
            result.y = -vector.y;
            return result;
          }
        ];
        break;

      case 'right-bottom':
        transformer = [
          function(point) {
            var result = {};
            result.x = chartArea.width + 2 * (chartArea.left || 0) - point.x;
            result.y = chartArea.height + 2 * (chartArea.top || 0) - point.y;
            return result;
          },
          function(vector) {
            var result = {};
            result.x = -vector.x;
            result.y = -vector.y;
            return result;
          }
        ];
        break;

      case 'right-top':
        transformer = [
          function(point) {
            var result = {};
            result.x = chartArea.width + 2 * (chartArea.left || 0) - point.x;
            result.y = point.y;
            return result;
          },
          function(vector) {
            var result = {};
            result.x = -vector.x;
            result.y = vector.y;
            return result;
          }
        ];
        break;

      // screen coordinates
      case 'left-top':
      default:
        transformer = [
          function(point) {
            return point;
          },
          function(vector) {
            return vector;
          }
        ];
        break;
    }

    return {
      convertPoint: transformer[0],
      convertVector: transformer[1]
    };
  }

  function pointsToMoves(points) {
    var prevP;
    var moves = [];

    points.forEach(function(p) {
      if (prevP) {
        var move = {
          x: p.x - prevP.x,
          y: p.y - prevP.y
        };
        moves.push(move);
      }
      prevP = p;
    });
    return moves;
  }

  function setAttributes(element, attrs) {
    Object.keys(attrs).forEach(function(attrName) {
      element.setAttribute(attrName, attrs[attrName]);
    });
  }

  function toAttributes(properties) {
    return Object.keys(properties).reduce(function(memo, propName) {
      var attrName = Polymer.CaseMap.camelToDashCase(propName);
      memo[attrName] = properties[propName];
      return memo;
    }, {});
  }

})();
</script>
